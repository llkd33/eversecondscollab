# ê±°ë˜ ë°ì´í„° ê´€ë¦¬ ì‹œìŠ¤í…œ ê¸°íšì„œ

## ğŸ“Š ê°œìš”

### 1.1 ëª©ì 
í”Œë«í¼ì˜ ëª¨ë“  ê±°ë˜ ë°ì´í„°ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ìˆ˜ì§‘, ì €ì¥, ë¶„ì„í•˜ì—¬ ë¹„ì¦ˆë‹ˆìŠ¤ ì¸ì‚¬ì´íŠ¸ë¥¼ ë„ì¶œí•˜ê³  ì„œë¹„ìŠ¤ ê°œì„ ì— í™œìš©

### 1.2 í•µì‹¬ ê°€ì¹˜
- **ë°ì´í„° ê¸°ë°˜ ì˜ì‚¬ê²°ì •**: ì‹¤ì‹œê°„ í†µê³„ ë° íŠ¸ë Œë“œ ë¶„ì„
- **ì‚¬ìš©ì í–‰ë™ ì´í•´**: íŒ¨í„´ ë¶„ì„ì„ í†µí•œ UX ê°œì„ 
- **í”Œë«í¼ ì„±ì¥**: í•µì‹¬ ì§€í‘œ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”

### 1.3 ì£¼ìš” ê¸°ëŠ¥
- ê±°ë˜ ë°ì´í„° ìˆ˜ì§‘ ë° ì €ì¥
- ì‹¤ì‹œê°„ í†µê³„ ëŒ€ì‹œë³´ë“œ
- ì‚¬ìš©ì í–‰ë™ ë¶„ì„
- ë°ì´í„° ë‚´ë³´ë‚´ê¸° ë° ë¦¬í¬íŒ…
- ìë™í™”ëœ ì•Œë¦¼ ì‹œìŠ¤í…œ

---

## ğŸ¯ ìˆ˜ì§‘ ë°ì´í„°

### 2.1 ë°ì´í„° ì¹´í…Œê³ ë¦¬

```typescript
// 1. ìƒí’ˆ ë°ì´í„°
interface ProductData {
  // ê¸°ë³¸ ì •ë³´
  id: string;
  title: string;
  category: string;
  price: number;
  condition: string;

  // í†µê³„
  views: number;
  likes: number;
  contacts: number;

  // íƒ€ì„ìŠ¤íƒ¬í”„
  createdAt: Date;
  soldAt?: Date;
  deletedAt?: Date;
}

// 2. ì‚¬ìš©ì ë°ì´í„°
interface UserData {
  id: string;
  role: string;

  // í™œë™
  totalProducts: number;
  totalSales: number;
  rating: number;

  // íƒ€ì„ìŠ¤íƒ¬í”„
  createdAt: Date;
  lastLoginAt: Date;
}

// 3. ê±°ë˜ ë°ì´í„°
interface TransactionData {
  id: string;
  productId: string;
  sellerId: string;
  buyerId: string;
  amount: number;
  status: string;

  createdAt: Date;
  completedAt?: Date;
}

// 4. ì´ë²¤íŠ¸ ë°ì´í„°
interface EventData {
  id: string;
  userId?: string;
  eventType: string;
  eventData: any;

  timestamp: Date;
  sessionId: string;
  userAgent: string;
  ipAddress: string;
}
```

---

## ğŸ“ˆ í†µê³„ ì‹œìŠ¤í…œ

### 3.1 ì‹¤ì‹œê°„ í†µê³„

**KPI (Key Performance Indicators)**:
```typescript
interface PlatformKPIs {
  // ì‚¬ìš©ì ì§€í‘œ
  totalUsers: number;
  activeUsers: number;      // DAU (Daily Active Users)
  newUsersToday: number;
  userGrowthRate: number;   // %

  // ìƒí’ˆ ì§€í‘œ
  totalProducts: number;
  activeProducts: number;
  newProductsToday: number;
  productGrowthRate: number;

  // ê±°ë˜ ì§€í‘œ
  totalTransactions: number;
  transactionsToday: number;
  conversionRate: number;    // ë“±ë¡ ëŒ€ë¹„ ê±°ë˜ ë¹„ìœ¨
  averageTransactionValue: number;

  // ì°¸ì—¬ ì§€í‘œ
  totalViews: number;
  totalLikes: number;
  totalContacts: number;

  // í’ˆì§ˆ ì§€í‘œ
  averageRating: number;
  totalReviews: number;
  reportRate: number;        // ì‹ ê³ ìœ¨
}

// KPI ê³„ì‚° í•¨ìˆ˜
async function calculateKPIs(period: 'today' | 'week' | 'month'): Promise<PlatformKPIs> {
  const now = new Date();
  let startDate: Date;

  switch (period) {
    case 'today':
      startDate = new Date(now.setHours(0, 0, 0, 0));
      break;
    case 'week':
      startDate = new Date(now.setDate(now.getDate() - 7));
      break;
    case 'month':
      startDate = new Date(now.setMonth(now.getMonth() - 1));
      break;
  }

  // Supabase RPC í˜¸ì¶œ
  const { data, error } = await supabase.rpc('calculate_kpis', {
    start_date: startDate.toISOString(),
    end_date: new Date().toISOString(),
  });

  if (error) throw error;

  return data;
}
```

### 3.2 íŠ¸ë Œë“œ ë¶„ì„

```typescript
interface TrendData {
  date: string;
  value: number;
  change?: number;  // vs ì´ì „ ê¸°ê°„
}

// ì¼ë³„ íŠ¸ë Œë“œ
async function getDailyTrend(
  metric: 'users' | 'products' | 'transactions',
  days: number = 30
): Promise<TrendData[]> {
  const { data, error } = await supabase.rpc('get_daily_trend', {
    metric_type: metric,
    num_days: days,
  });

  if (error) throw error;

  return data.map((item, index) => ({
    date: item.date,
    value: item.value,
    change: index > 0 ? ((item.value - data[index - 1].value) / data[index - 1].value) * 100 : 0,
  }));
}

// SQL í•¨ìˆ˜
CREATE OR REPLACE FUNCTION get_daily_trend(
  metric_type TEXT,
  num_days INTEGER
)
RETURNS TABLE(date DATE, value BIGINT) AS $$
BEGIN
  CASE metric_type
    WHEN 'users' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM users
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;

    WHEN 'products' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM products
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;

    WHEN 'transactions' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM transactions
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ‘¥ ì‚¬ìš©ì í–‰ë™ ë¶„ì„

### 4.1 ì‚¬ìš©ì ì„¸ê·¸ë¨¼í…Œì´ì…˜

```typescript
interface UserSegment {
  segmentName: string;
  criteria: any;
  userCount: number;
  characteristics: string[];
}

// ì„¸ê·¸ë¨¼íŠ¸ ì •ì˜
const userSegments: UserSegment[] = [
  {
    segmentName: 'íŒŒì›Œ ì…€ëŸ¬',
    criteria: { totalSales: { gte: 10 }, rating: { gte: 4.5 } },
    userCount: 0,
    characteristics: ['ë†’ì€ íŒë§¤ ì‹¤ì ', 'ë†’ì€ í‰ì ', 'í™œë°œí•œ í™œë™'],
  },
  {
    segmentName: 'ì‹ ê·œ íŒë§¤ì',
    criteria: { totalProducts: { lte: 3 }, createdAt: { gte: '7days' } },
    userCount: 0,
    characteristics: ['ìµœê·¼ ê°€ì…', 'ì´ˆê¸° ìƒí’ˆ ë“±ë¡ ë‹¨ê³„'],
  },
  {
    segmentName: 'í™œì„± êµ¬ë§¤ì',
    criteria: { totalPurchases: { gte: 3 }, lastActivityAt: { gte: '30days' } },
    userCount: 0,
    characteristics: ['ë¹ˆë²ˆí•œ êµ¬ë§¤', 'ìµœê·¼ í™œë™'],
  },
  {
    segmentName: 'íœ´ë©´ ì‚¬ìš©ì',
    criteria: { lastActivityAt: { lte: '90days' } },
    userCount: 0,
    characteristics: ['ì¥ê¸° ë¯¸í™œë™', 'ì¬í™œì„±í™” í•„ìš”'],
  },
];

// ì„¸ê·¸ë¨¼íŠ¸ë³„ ì‚¬ìš©ì ì¡°íšŒ
async function getUsersBySegment(segment: UserSegment): Promise<any[]> {
  let query = supabase.from('users').select('*');

  // ì¡°ê±´ ì ìš©
  Object.entries(segment.criteria).forEach(([key, condition]) => {
    if (typeof condition === 'object') {
      if ('gte' in condition) {
        query = query.gte(key, condition.gte);
      }
      if ('lte' in condition) {
        query = query.lte(key, condition.lte);
      }
    }
  });

  const { data, error } = await query;
  if (error) throw error;

  return data;
}
```

### 4.2 ì½”í˜¸íŠ¸ ë¶„ì„

```typescript
interface CohortData {
  cohort: string;        // ê°€ì… ì›”
  month: number;         // ê²½ê³¼ ì›”
  userCount: number;     // ì‚¬ìš©ì ìˆ˜
  retentionRate: number; // ìœ ì§€ìœ¨ (%)
}

// ì½”í˜¸íŠ¸ ë¶„ì„ (ì›”ë³„ ê°€ì…ìì˜ ë¦¬í…ì…˜)
async function getCohortAnalysis(months: number = 6): Promise<CohortData[]> {
  const { data, error } = await supabase.rpc('get_cohort_analysis', {
    num_months: months,
  });

  if (error) throw error;

  return data;
}

// SQL í•¨ìˆ˜
CREATE OR REPLACE FUNCTION get_cohort_analysis(num_months INTEGER)
RETURNS TABLE(
  cohort TEXT,
  month INTEGER,
  user_count INTEGER,
  retention_rate DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH cohorts AS (
    SELECT
      id AS user_id,
      DATE_TRUNC('month', created_at) AS cohort_month
    FROM users
    WHERE created_at >= CURRENT_DATE - (num_months || ' months')::INTERVAL
  ),
  activities AS (
    SELECT
      u.id AS user_id,
      DATE_TRUNC('month', p.created_at) AS activity_month
    FROM users u
    LEFT JOIN products p ON u.id = p.seller_id
    WHERE p.created_at IS NOT NULL
  )
  SELECT
    TO_CHAR(c.cohort_month, 'YYYY-MM') AS cohort,
    EXTRACT(MONTH FROM AGE(a.activity_month, c.cohort_month))::INTEGER AS month,
    COUNT(DISTINCT c.user_id)::INTEGER AS user_count,
    (COUNT(DISTINCT c.user_id)::DECIMAL /
     (SELECT COUNT(*) FROM cohorts WHERE cohort_month = c.cohort_month)) * 100 AS retention_rate
  FROM cohorts c
  LEFT JOIN activities a ON c.user_id = a.user_id
  GROUP BY c.cohort_month, month
  ORDER BY cohort, month;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 í¼ë„ ë¶„ì„

```typescript
interface FunnelStep {
  step: string;
  count: number;
  conversionRate: number; // %
  dropOffRate: number;    // %
}

// ìƒí’ˆ ë“±ë¡ í¼ë„
const productRegistrationFunnel: FunnelStep[] = [
  { step: 'ì¹´í…Œê³ ë¦¬ ì„ íƒ', count: 0, conversionRate: 100, dropOffRate: 0 },
  { step: 'ìƒí’ˆ ì •ë³´ ì…ë ¥', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: 'ì‚¬ì§„ ì—…ë¡œë“œ', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: 'ì •ë³´ í™•ì¸', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: 'ë“±ë¡ ì™„ë£Œ', count: 0, conversionRate: 0, dropOffRate: 0 },
];

// êµ¬ë§¤ í¼ë„
const purchaseFunnel: FunnelStep[] = [
  { step: 'ìƒí’ˆ ì¡°íšŒ', count: 0, conversionRate: 100, dropOffRate: 0 },
  { step: 'ìƒí’ˆ ìƒì„¸', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: 'íŒë§¤ì ì—°ë½', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: 'ê±°ë˜ ì™„ë£Œ', count: 0, conversionRate: 0, dropOffRate: 0 },
];

// í¼ë„ ë°ì´í„° ìˆ˜ì§‘
async function trackFunnelEvent(funnel: string, step: string, userId?: string) {
  await supabase.from('funnel_events').insert({
    funnel_type: funnel,
    step: step,
    user_id: userId,
    session_id: getSessionId(),
    timestamp: new Date().toISOString(),
  });
}

// í¼ë„ ë¶„ì„ ì¡°íšŒ
async function analyzeFunnel(funnelType: string, period: 'day' | 'week' | 'month'): Promise<FunnelStep[]> {
  const { data, error } = await supabase.rpc('analyze_funnel', {
    funnel_type: funnelType,
    period_type: period,
  });

  if (error) throw error;

  // ì „í™˜ìœ¨ ê³„ì‚°
  const totalCount = data[0]?.count || 1;
  return data.map((item, index) => ({
    step: item.step,
    count: item.count,
    conversionRate: (item.count / totalCount) * 100,
    dropOffRate: index > 0 ? ((data[index - 1].count - item.count) / data[index - 1].count) * 100 : 0,
  }));
}
```

---

## ğŸ“Š ì¹´í…Œê³ ë¦¬ ë¶„ì„

### 5.1 ì¹´í…Œê³ ë¦¬ë³„ í†µê³„

```typescript
interface CategoryStats {
  categoryId: string;
  categoryName: string;

  // ìƒí’ˆ ìˆ˜
  totalProducts: number;
  activeProducts: number;
  soldProducts: number;

  // ê±°ë˜ í†µê³„
  totalTransactions: number;
  totalRevenue: number;
  averagePrice: number;

  // ì„±ê³¼ ì§€í‘œ
  conversionRate: number;  // %
  averageSellTime: number; // ì¼
  popularityScore: number; // 0-100
}

// ì¹´í…Œê³ ë¦¬ë³„ í†µê³„ ì¡°íšŒ
async function getCategoryStats(): Promise<CategoryStats[]> {
  const { data, error } = await supabase.rpc('get_category_stats');

  if (error) throw error;

  return data;
}

// SQL í•¨ìˆ˜
CREATE OR REPLACE FUNCTION get_category_stats()
RETURNS TABLE(
  category_id UUID,
  category_name VARCHAR,
  total_products INTEGER,
  active_products INTEGER,
  sold_products INTEGER,
  total_transactions INTEGER,
  total_revenue BIGINT,
  average_price INTEGER,
  conversion_rate DECIMAL,
  average_sell_time DECIMAL,
  popularity_score DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id AS category_id,
    c.name AS category_name,
    COUNT(p.id)::INTEGER AS total_products,
    COUNT(p.id) FILTER (WHERE p.status = 'active')::INTEGER AS active_products,
    COUNT(p.id) FILTER (WHERE p.status = 'sold')::INTEGER AS sold_products,
    COUNT(t.id)::INTEGER AS total_transactions,
    COALESCE(SUM(t.amount), 0)::BIGINT AS total_revenue,
    COALESCE(AVG(p.price), 0)::INTEGER AS average_price,
    CASE
      WHEN COUNT(p.id) > 0 THEN
        (COUNT(t.id)::DECIMAL / COUNT(p.id) * 100)
      ELSE 0
    END AS conversion_rate,
    COALESCE(AVG(EXTRACT(DAY FROM (p.sold_at - p.created_at))), 0)::DECIMAL AS average_sell_time,
    CASE
      WHEN COUNT(p.id) > 0 THEN
        ((COUNT(p.id) * 0.3 + COUNT(t.id) * 0.4 + SUM(p.views) * 0.3) / GREATEST(COUNT(p.id), 1))::DECIMAL
      ELSE 0
    END AS popularity_score
  FROM categories c
  LEFT JOIN products p ON c.id = p.category_id
  LEFT JOIN transactions t ON p.id = t.product_id
  GROUP BY c.id, c.name
  ORDER BY popularity_score DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸŒ ì§€ì—­ ë¶„ì„

### 6.1 ê±°ë˜ ì§€ì—­ í†µê³„

```typescript
interface RegionStats {
  region: string;

  // í™œë™ í†µê³„
  userCount: number;
  productCount: number;
  transactionCount: number;

  // ê±°ë˜ íŠ¹ì„±
  averagePrice: number;
  popularCategories: string[];

  // ì„±ì¥ë¥ 
  growthRate: number; // %
}

// ì§€ì—­ë³„ í†µê³„ ì¡°íšŒ
async function getRegionStats(): Promise<RegionStats[]> {
  const { data, error } = await supabase.rpc('get_region_stats');

  if (error) throw error;

  return data;
}
```

---

## ğŸ“± ì´ë²¤íŠ¸ ì¶”ì 

### 7.1 ì´ë²¤íŠ¸ íƒ€ì…

```typescript
enum EventType {
  // í˜ì´ì§€ ì¡°íšŒ
  PAGE_VIEW = 'page_view',

  // ìƒí’ˆ ê´€ë ¨
  PRODUCT_VIEW = 'product_view',
  PRODUCT_CREATE = 'product_create',
  PRODUCT_UPDATE = 'product_update',
  PRODUCT_DELETE = 'product_delete',

  // ì‚¬ìš©ì í–‰ë™
  SEARCH = 'search',
  FILTER_APPLY = 'filter_apply',
  WISHLIST_ADD = 'wishlist_add',
  WISHLIST_REMOVE = 'wishlist_remove',

  // ì—°ë½ ë° ê±°ë˜
  CONTACT_SELLER = 'contact_seller',
  TRANSACTION_INITIATE = 'transaction_initiate',
  TRANSACTION_COMPLETE = 'transaction_complete',

  // QR ì½”ë“œ
  QR_SCAN = 'qr_scan',
  QR_GENERATE = 'qr_generate',

  // ì‚¬ìš©ì ê³„ì •
  USER_SIGNUP = 'user_signup',
  USER_LOGIN = 'user_login',
  USER_LOGOUT = 'user_logout',
}

// ì´ë²¤íŠ¸ ì¶”ì  í•¨ìˆ˜
async function trackEvent(
  eventType: EventType,
  eventData?: any,
  userId?: string
) {
  const event = {
    event_type: eventType,
    event_data: eventData,
    user_id: userId,
    session_id: getSessionId(),
    timestamp: new Date().toISOString(),
    user_agent: navigator.userAgent,
    referrer: document.referrer,
    page_url: window.location.href,
  };

  // ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
  await supabase.from('events').insert(event);

  // Google Analytics (ì„ íƒì )
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', eventType, eventData);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
trackEvent(EventType.PRODUCT_VIEW, {
  productId: 'abc-123',
  productTitle: 'ì•„ì´í° 13 Pro',
  price: 800000,
  category: 'ì „ìê¸°ê¸°',
});

trackEvent(EventType.SEARCH, {
  query: 'ì•„ì´í°',
  resultCount: 42,
});

trackEvent(EventType.CONTACT_SELLER, {
  productId: 'abc-123',
  sellerId: 'seller-456',
});
```

### 7.2 ì„¸ì…˜ ê´€ë¦¬

```typescript
// ì„¸ì…˜ ID ìƒì„± ë° ê´€ë¦¬
function getSessionId(): string {
  let sessionId = sessionStorage.getItem('session_id');

  if (!sessionId) {
    sessionId = crypto.randomUUID();
    sessionStorage.setItem('session_id', sessionId);
    sessionStorage.setItem('session_start', new Date().toISOString());
  }

  return sessionId;
}

// ì„¸ì…˜ í†µê³„
interface SessionStats {
  sessionId: string;
  userId?: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;  // ì´ˆ
  pageViews: number;
  events: number;
  bounceRate: boolean; // ë‹¨ì¼ í˜ì´ì§€ ë°©ë¬¸ ì—¬ë¶€
}

// ì„¸ì…˜ ë¶„ì„
async function analyzeSession(sessionId: string): Promise<SessionStats> {
  const { data: events, error } = await supabase
    .from('events')
    .select('*')
    .eq('session_id', sessionId)
    .order('timestamp', { ascending: true });

  if (error) throw error;

  const startTime = new Date(events[0].timestamp);
  const endTime = new Date(events[events.length - 1].timestamp);
  const duration = (endTime.getTime() - startTime.getTime()) / 1000;

  const pageViews = events.filter(e => e.event_type === EventType.PAGE_VIEW).length;
  const bounceRate = pageViews === 1;

  return {
    sessionId,
    userId: events[0].user_id,
    startTime,
    endTime,
    duration,
    pageViews,
    events: events.length,
    bounceRate,
  };
}
```

---

## ğŸ“¤ ë°ì´í„° ë‚´ë³´ë‚´ê¸°

### 8.1 CSV ë‚´ë³´ë‚´ê¸°

```typescript
import { saveAs } from 'file-saver';

async function exportToCSV(
  dataType: 'products' | 'users' | 'transactions',
  filters?: any
) {
  // ë°ì´í„° ì¡°íšŒ
  const data = await fetchData(dataType, filters);

  // CSV ë³€í™˜
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row =>
      headers.map(header =>
        JSON.stringify(row[header] || '')
      ).join(',')
    ),
  ].join('\n');

  // BOM ì¶”ê°€ (í•œê¸€ ê¹¨ì§ ë°©ì§€)
  const blob = new Blob(['\uFEFF' + csvContent], {
    type: 'text/csv;charset=utf-8;',
  });

  // íŒŒì¼ ì €ì¥
  const filename = `${dataType}_${new Date().toISOString()}.csv`;
  saveAs(blob, filename);
}
```

### 8.2 Excel ë‚´ë³´ë‚´ê¸°

```typescript
import * as XLSX from 'xlsx';

async function exportToExcel(
  dataType: string,
  data: any[],
  filename: string
) {
  // ì›Œí¬ì‹œíŠ¸ ìƒì„±
  const ws = XLSX.utils.json_to_sheet(data);

  // ì—´ ë„ˆë¹„ ìë™ ì¡°ì •
  const colWidths = Object.keys(data[0]).map(key => ({
    wch: Math.max(key.length, 15),
  }));
  ws['!cols'] = colWidths;

  // ì›Œí¬ë¶ ìƒì„±
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, dataType);

  // íŒŒì¼ ì €ì¥
  XLSX.writeFile(wb, filename);
}
```

---

## ğŸ“Š ë¦¬í¬íŠ¸ ìƒì„±

### 9.1 ìë™ ë¦¬í¬íŠ¸

```typescript
interface Report {
  id: string;
  type: 'daily' | 'weekly' | 'monthly';
  period: {
    start: Date;
    end: Date;
  };
  kpis: PlatformKPIs;
  trends: TrendData[];
  insights: string[];
  generatedAt: Date;
}

// ì¼ì¼ ë¦¬í¬íŠ¸ ìƒì„±
async function generateDailyReport(): Promise<Report> {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  // KPI ìˆ˜ì§‘
  const kpis = await calculateKPIs('today');

  // íŠ¸ë Œë“œ ë°ì´í„°
  const trends = await getDailyTrend('transactions', 7);

  // ì¸ì‚¬ì´íŠ¸ ìƒì„±
  const insights = generateInsights(kpis, trends);

  const report: Report = {
    id: crypto.randomUUID(),
    type: 'daily',
    period: {
      start: new Date(today.setHours(0, 0, 0, 0)),
      end: new Date(today.setHours(23, 59, 59, 999)),
    },
    kpis,
    trends,
    insights,
    generatedAt: new Date(),
  };

  // ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
  await supabase.from('reports').insert(report);

  // ê´€ë¦¬ìì—ê²Œ ì´ë©”ì¼ ë°œì†¡
  await sendReportEmail(report);

  return report;
}

// ì¸ì‚¬ì´íŠ¸ ìƒì„±
function generateInsights(kpis: PlatformKPIs, trends: TrendData[]): string[] {
  const insights: string[] = [];

  // ì„±ì¥ë¥  ë¶„ì„
  if (kpis.userGrowthRate > 10) {
    insights.push(`ì‚¬ìš©ìê°€ ${kpis.userGrowthRate.toFixed(1)}% ì¦ê°€í–ˆìŠµë‹ˆë‹¤! ğŸ‰`);
  }

  // ê±°ë˜ íŠ¸ë Œë“œ
  const recentTrend = trends.slice(-3);
  const avgChange = recentTrend.reduce((sum, t) => sum + (t.change || 0), 0) / recentTrend.length;
  if (avgChange > 0) {
    insights.push(`ìµœê·¼ 3ì¼ê°„ ê±°ë˜ê°€ í‰ê·  ${avgChange.toFixed(1)}% ì¦ê°€í•˜ê³  ìˆìŠµë‹ˆë‹¤.`);
  }

  // ì „í™˜ìœ¨ ë¶„ì„
  if (kpis.conversionRate < 20) {
    insights.push(`ì „í™˜ìœ¨ì´ ${kpis.conversionRate.toFixed(1)}%ë¡œ ë‚®ìŠµë‹ˆë‹¤. UX ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.`);
  }

  // ì‚¬ìš©ì ì°¸ì—¬
  const engagementRate = (kpis.activeUsers / kpis.totalUsers) * 100;
  if (engagementRate < 30) {
    insights.push(`í™œì„± ì‚¬ìš©ì ë¹„ìœ¨ì´ ${engagementRate.toFixed(1)}%ì…ë‹ˆë‹¤. ì¬ì°¸ì—¬ ìº í˜ì¸ì„ ê³ ë ¤í•˜ì„¸ìš”.`);
  }

  return insights;
}
```

### 9.2 ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ë§

```typescript
// Vercel Cron Jobs ë˜ëŠ” Supabase Edge Functions ì‚¬ìš©
// vercel.json
{
  "crons": [
    {
      "path": "/api/cron/daily-report",
      "schedule": "0 9 * * *"  // ë§¤ì¼ ì˜¤ì „ 9ì‹œ
    },
    {
      "path": "/api/cron/weekly-report",
      "schedule": "0 9 * * 1"  // ë§¤ì£¼ ì›”ìš”ì¼ ì˜¤ì „ 9ì‹œ
    },
    {
      "path": "/api/cron/monthly-report",
      "schedule": "0 9 1 * *"  // ë§¤ì›” 1ì¼ ì˜¤ì „ 9ì‹œ
    }
  ]
}

// API Route: /api/cron/daily-report
export async function GET(request: Request) {
  // ë³´ì•ˆ: Cron ë¹„ë°€í‚¤ í™•ì¸
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const report = await generateDailyReport();
    return Response.json({ success: true, report });
  } catch (error) {
    console.error('Report generation failed:', error);
    return Response.json({ success: false, error }, { status: 500 });
  }
}
```

---

## ğŸ”” ì•Œë¦¼ ì‹œìŠ¤í…œ

### 10.1 ì•Œë¦¼ íŠ¸ë¦¬ê±°

```typescript
interface NotificationTrigger {
  condition: string;
  threshold: number;
  action: () => Promise<void>;
}

// ì•Œë¦¼ íŠ¸ë¦¬ê±° ì •ì˜
const notificationTriggers: NotificationTrigger[] = [
  {
    condition: 'newUsersToday',
    threshold: 50,
    action: async () => {
      await sendSlackNotification('ğŸ‰ ì˜¤ëŠ˜ ì‹ ê·œ ê°€ì…ìê°€ 50ëª…ì„ ëŒíŒŒí–ˆìŠµë‹ˆë‹¤!');
    },
  },
  {
    condition: 'conversionRate',
    threshold: 15,
    action: async () => {
      await sendEmail({
        to: 'admin@everseconds.com',
        subject: 'âš ï¸ ì „í™˜ìœ¨ ê²½ê³ ',
        body: 'ì „í™˜ìœ¨ì´ 15% ì´í•˜ë¡œ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤. í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.',
      });
    },
  },
  {
    condition: 'errorRate',
    threshold: 5,
    action: async () => {
      await sendPagerDutyAlert('Critical: Error rate exceeds 5%');
    },
  },
];

// ì•Œë¦¼ ì²´í¬ ë° ë°œì†¡
async function checkAndSendNotifications() {
  const kpis = await calculateKPIs('today');

  for (const trigger of notificationTriggers) {
    const value = kpis[trigger.condition];

    if (value && value >= trigger.threshold) {
      await trigger.action();
    }
  }
}
```

### 10.2 Slack í†µí•©

```typescript
async function sendSlackNotification(message: string, channel: string = '#analytics') {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL!;

  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      channel,
      text: message,
      username: 'Analytics Bot',
      icon_emoji: ':bar_chart:',
    }),
  });
}
```

---

## ğŸ” ë°ì´í„° ë³´ì•ˆ ë° í”„ë¼ì´ë²„ì‹œ

### 11.1 ë°ì´í„° ìµëª…í™”

```typescript
// PII (Personally Identifiable Information) ë§ˆìŠ¤í‚¹
function maskEmail(email: string): string {
  const [username, domain] = email.split('@');
  const maskedUsername = username.slice(0, 2) + '***';
  return `${maskedUsername}@${domain}`;
}

function maskPhone(phone: string): string {
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1-****-$2');
}

// ìµëª…í™”ëœ ë¶„ì„ ë°ì´í„°
interface AnonymizedUserData {
  userId: string;        // í•´ì‹œëœ ID
  ageGroup: string;      // "20ëŒ€", "30ëŒ€" ë“±
  region: string;        // "ì„œìš¸ì‹œ", "ê²½ê¸°ë„" ë“± (êµ¬ì²´ì ì¸ ì£¼ì†Œ ì œì™¸)
  activityLevel: string; // "high", "medium", "low"
}
```

### 11.2 ë°ì´í„° ë³´ê´€ ì •ì±…

```typescript
// ë°ì´í„° ë³´ê´€ ê¸°ê°„
const dataRetentionPolicy = {
  events: 90,          // ì¼
  logs: 30,
  reports: 365,
  transactions: Infinity, // ì˜êµ¬ ë³´ê´€
};

// ì˜¤ë˜ëœ ë°ì´í„° ì‚­ì œ
async function cleanupOldData() {
  const now = new Date();

  for (const [table, days] of Object.entries(dataRetentionPolicy)) {
    if (days === Infinity) continue;

    const cutoffDate = new Date(now);
    cutoffDate.setDate(cutoffDate.getDate() - days);

    await supabase
      .from(table)
      .delete()
      .lt('created_at', cutoffDate.toISOString());
  }
}
```

---

## ğŸ“Š ì‹œê°í™”

### 12.1 ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬

```typescript
import { LineChart, BarChart, PieChart, AreaChart } from 'recharts';

// ë¼ì¸ ì°¨íŠ¸ (íŠ¸ë Œë“œ)
function TrendChart({ data }: { data: TrendData[] }) {
  return (
    <LineChart width={600} height={300} data={data}>
      <XAxis dataKey="date" />
      <YAxis />
      <Tooltip />
      <Line type="monotone" dataKey="value" stroke="#2563eb" />
    </LineChart>
  );
}

// ë°” ì°¨íŠ¸ (ì¹´í…Œê³ ë¦¬ë³„ ë¹„êµ)
function CategoryChart({ data }: { data: CategoryStats[] }) {
  return (
    <BarChart width={600} height={300} data={data}>
      <XAxis dataKey="categoryName" />
      <YAxis />
      <Tooltip />
      <Bar dataKey="totalProducts" fill="#2563eb" />
    </BarChart>
  );
}

// íŒŒì´ ì°¨íŠ¸ (ë¹„ìœ¨)
function MarketShareChart({ data }: { data: any[] }) {
  return (
    <PieChart width={400} height={300}>
      <Pie
        data={data}
        dataKey="value"
        nameKey="name"
        cx="50%"
        cy="50%"
        outerRadius={100}
        fill="#2563eb"
        label
      />
      <Tooltip />
    </PieChart>
  );
}
```

---

## ğŸ§ª A/B í…ŒìŠ¤íŠ¸

### 13.1 ì‹¤í—˜ ì„¤ì •

```typescript
interface Experiment {
  id: string;
  name: string;
  description: string;
  variants: {
    id: string;
    name: string;
    weight: number; // 0-1 (íŠ¸ë˜í”½ ë¹„ìœ¨)
  }[];
  startDate: Date;
  endDate?: Date;
  status: 'draft' | 'running' | 'completed';
}

// ì‹¤í—˜ ìƒì„±
async function createExperiment(experiment: Omit<Experiment, 'id'>): Promise<Experiment> {
  const { data, error } = await supabase
    .from('experiments')
    .insert({ ...experiment, id: crypto.randomUUID() })
    .select()
    .single();

  if (error) throw error;

  return data;
}

// ì‚¬ìš©ìë¥¼ ë³€í˜•ì— í• ë‹¹
function assignVariant(experimentId: string, userId: string): string {
  // í•´ì‹œ ê¸°ë°˜ ì¼ê´€ëœ í• ë‹¹
  const hash = crypto.createHash('md5')
    .update(`${experimentId}:${userId}`)
    .digest('hex');

  const hashValue = parseInt(hash.slice(0, 8), 16) / 0xffffffff;

  // ì‹¤í—˜ ì¡°íšŒ ë° ë³€í˜• ì„ íƒ
  // ... (ìƒëµ)

  return variantId;
}
```

---

## ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### 14.1 ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
interface PerformanceMetrics {
  // Web Vitals
  lcp: number;  // Largest Contentful Paint
  fid: number;  // First Input Delay
  cls: number;  // Cumulative Layout Shift

  // Custom Metrics
  apiResponseTime: number;
  databaseQueryTime: number;
  imageLoadTime: number;
}

// Web Vitals ì¸¡ì •
import { getCLS, getFID, getLCP } from 'web-vitals';

function measureWebVitals() {
  getCLS(metric => sendMetric('cls', metric.value));
  getFID(metric => sendMetric('fid', metric.value));
  getLCP(metric => sendMetric('lcp', metric.value));
}

async function sendMetric(name: string, value: number) {
  await supabase.from('performance_metrics').insert({
    metric_name: name,
    value: value,
    page_url: window.location.href,
    timestamp: new Date().toISOString(),
  });
}
```

---

**ë¬¸ì„œ ë²„ì „**: 1.0
**ìµœì¢… ìˆ˜ì •ì¼**: 2025-10-30
**ì‘ì„±ì**: ì—ë²„ì„¸ì»¨ì¦ˆ ê°œë°œíŒ€
**ê´€ë ¨ ë¬¸ì„œ**: [í”„ë¡œì íŠ¸ ê°œìš”](./í”„ë¡œì íŠ¸_ê°œìš”.md), [ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡° ì„¤ê³„ì„œ](./ë°ì´í„°ë² ì´ìŠ¤_êµ¬ì¡°_ì„¤ê³„ì„œ.md)
