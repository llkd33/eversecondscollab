# 거래 데이터 관리 시스템 기획서

## 📊 개요

### 1.1 목적
플랫폼의 모든 거래 데이터를 체계적으로 수집, 저장, 분석하여 비즈니스 인사이트를 도출하고 서비스 개선에 활용

### 1.2 핵심 가치
- **데이터 기반 의사결정**: 실시간 통계 및 트렌드 분석
- **사용자 행동 이해**: 패턴 분석을 통한 UX 개선
- **플랫폼 성장**: 핵심 지표 모니터링 및 최적화

### 1.3 주요 기능
- 거래 데이터 수집 및 저장
- 실시간 통계 대시보드
- 사용자 행동 분석
- 데이터 내보내기 및 리포팅
- 자동화된 알림 시스템

---

## 🎯 수집 데이터

### 2.1 데이터 카테고리

```typescript
// 1. 상품 데이터
interface ProductData {
  // 기본 정보
  id: string;
  title: string;
  category: string;
  price: number;
  condition: string;

  // 통계
  views: number;
  likes: number;
  contacts: number;

  // 타임스탬프
  createdAt: Date;
  soldAt?: Date;
  deletedAt?: Date;
}

// 2. 사용자 데이터
interface UserData {
  id: string;
  role: string;

  // 활동
  totalProducts: number;
  totalSales: number;
  rating: number;

  // 타임스탬프
  createdAt: Date;
  lastLoginAt: Date;
}

// 3. 거래 데이터
interface TransactionData {
  id: string;
  productId: string;
  sellerId: string;
  buyerId: string;
  amount: number;
  status: string;

  createdAt: Date;
  completedAt?: Date;
}

// 4. 이벤트 데이터
interface EventData {
  id: string;
  userId?: string;
  eventType: string;
  eventData: any;

  timestamp: Date;
  sessionId: string;
  userAgent: string;
  ipAddress: string;
}
```

---

## 📈 통계 시스템

### 3.1 실시간 통계

**KPI (Key Performance Indicators)**:
```typescript
interface PlatformKPIs {
  // 사용자 지표
  totalUsers: number;
  activeUsers: number;      // DAU (Daily Active Users)
  newUsersToday: number;
  userGrowthRate: number;   // %

  // 상품 지표
  totalProducts: number;
  activeProducts: number;
  newProductsToday: number;
  productGrowthRate: number;

  // 거래 지표
  totalTransactions: number;
  transactionsToday: number;
  conversionRate: number;    // 등록 대비 거래 비율
  averageTransactionValue: number;

  // 참여 지표
  totalViews: number;
  totalLikes: number;
  totalContacts: number;

  // 품질 지표
  averageRating: number;
  totalReviews: number;
  reportRate: number;        // 신고율
}

// KPI 계산 함수
async function calculateKPIs(period: 'today' | 'week' | 'month'): Promise<PlatformKPIs> {
  const now = new Date();
  let startDate: Date;

  switch (period) {
    case 'today':
      startDate = new Date(now.setHours(0, 0, 0, 0));
      break;
    case 'week':
      startDate = new Date(now.setDate(now.getDate() - 7));
      break;
    case 'month':
      startDate = new Date(now.setMonth(now.getMonth() - 1));
      break;
  }

  // Supabase RPC 호출
  const { data, error } = await supabase.rpc('calculate_kpis', {
    start_date: startDate.toISOString(),
    end_date: new Date().toISOString(),
  });

  if (error) throw error;

  return data;
}
```

### 3.2 트렌드 분석

```typescript
interface TrendData {
  date: string;
  value: number;
  change?: number;  // vs 이전 기간
}

// 일별 트렌드
async function getDailyTrend(
  metric: 'users' | 'products' | 'transactions',
  days: number = 30
): Promise<TrendData[]> {
  const { data, error } = await supabase.rpc('get_daily_trend', {
    metric_type: metric,
    num_days: days,
  });

  if (error) throw error;

  return data.map((item, index) => ({
    date: item.date,
    value: item.value,
    change: index > 0 ? ((item.value - data[index - 1].value) / data[index - 1].value) * 100 : 0,
  }));
}

// SQL 함수
CREATE OR REPLACE FUNCTION get_daily_trend(
  metric_type TEXT,
  num_days INTEGER
)
RETURNS TABLE(date DATE, value BIGINT) AS $$
BEGIN
  CASE metric_type
    WHEN 'users' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM users
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;

    WHEN 'products' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM products
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;

    WHEN 'transactions' THEN
      RETURN QUERY
      SELECT
        created_at::DATE AS date,
        COUNT(*) AS value
      FROM transactions
      WHERE created_at >= CURRENT_DATE - num_days
      GROUP BY date
      ORDER BY date;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

---

## 👥 사용자 행동 분석

### 4.1 사용자 세그먼테이션

```typescript
interface UserSegment {
  segmentName: string;
  criteria: any;
  userCount: number;
  characteristics: string[];
}

// 세그먼트 정의
const userSegments: UserSegment[] = [
  {
    segmentName: '파워 셀러',
    criteria: { totalSales: { gte: 10 }, rating: { gte: 4.5 } },
    userCount: 0,
    characteristics: ['높은 판매 실적', '높은 평점', '활발한 활동'],
  },
  {
    segmentName: '신규 판매자',
    criteria: { totalProducts: { lte: 3 }, createdAt: { gte: '7days' } },
    userCount: 0,
    characteristics: ['최근 가입', '초기 상품 등록 단계'],
  },
  {
    segmentName: '활성 구매자',
    criteria: { totalPurchases: { gte: 3 }, lastActivityAt: { gte: '30days' } },
    userCount: 0,
    characteristics: ['빈번한 구매', '최근 활동'],
  },
  {
    segmentName: '휴면 사용자',
    criteria: { lastActivityAt: { lte: '90days' } },
    userCount: 0,
    characteristics: ['장기 미활동', '재활성화 필요'],
  },
];

// 세그먼트별 사용자 조회
async function getUsersBySegment(segment: UserSegment): Promise<any[]> {
  let query = supabase.from('users').select('*');

  // 조건 적용
  Object.entries(segment.criteria).forEach(([key, condition]) => {
    if (typeof condition === 'object') {
      if ('gte' in condition) {
        query = query.gte(key, condition.gte);
      }
      if ('lte' in condition) {
        query = query.lte(key, condition.lte);
      }
    }
  });

  const { data, error } = await query;
  if (error) throw error;

  return data;
}
```

### 4.2 코호트 분석

```typescript
interface CohortData {
  cohort: string;        // 가입 월
  month: number;         // 경과 월
  userCount: number;     // 사용자 수
  retentionRate: number; // 유지율 (%)
}

// 코호트 분석 (월별 가입자의 리텐션)
async function getCohortAnalysis(months: number = 6): Promise<CohortData[]> {
  const { data, error } = await supabase.rpc('get_cohort_analysis', {
    num_months: months,
  });

  if (error) throw error;

  return data;
}

// SQL 함수
CREATE OR REPLACE FUNCTION get_cohort_analysis(num_months INTEGER)
RETURNS TABLE(
  cohort TEXT,
  month INTEGER,
  user_count INTEGER,
  retention_rate DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH cohorts AS (
    SELECT
      id AS user_id,
      DATE_TRUNC('month', created_at) AS cohort_month
    FROM users
    WHERE created_at >= CURRENT_DATE - (num_months || ' months')::INTERVAL
  ),
  activities AS (
    SELECT
      u.id AS user_id,
      DATE_TRUNC('month', p.created_at) AS activity_month
    FROM users u
    LEFT JOIN products p ON u.id = p.seller_id
    WHERE p.created_at IS NOT NULL
  )
  SELECT
    TO_CHAR(c.cohort_month, 'YYYY-MM') AS cohort,
    EXTRACT(MONTH FROM AGE(a.activity_month, c.cohort_month))::INTEGER AS month,
    COUNT(DISTINCT c.user_id)::INTEGER AS user_count,
    (COUNT(DISTINCT c.user_id)::DECIMAL /
     (SELECT COUNT(*) FROM cohorts WHERE cohort_month = c.cohort_month)) * 100 AS retention_rate
  FROM cohorts c
  LEFT JOIN activities a ON c.user_id = a.user_id
  GROUP BY c.cohort_month, month
  ORDER BY cohort, month;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 퍼널 분석

```typescript
interface FunnelStep {
  step: string;
  count: number;
  conversionRate: number; // %
  dropOffRate: number;    // %
}

// 상품 등록 퍼널
const productRegistrationFunnel: FunnelStep[] = [
  { step: '카테고리 선택', count: 0, conversionRate: 100, dropOffRate: 0 },
  { step: '상품 정보 입력', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: '사진 업로드', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: '정보 확인', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: '등록 완료', count: 0, conversionRate: 0, dropOffRate: 0 },
];

// 구매 퍼널
const purchaseFunnel: FunnelStep[] = [
  { step: '상품 조회', count: 0, conversionRate: 100, dropOffRate: 0 },
  { step: '상품 상세', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: '판매자 연락', count: 0, conversionRate: 0, dropOffRate: 0 },
  { step: '거래 완료', count: 0, conversionRate: 0, dropOffRate: 0 },
];

// 퍼널 데이터 수집
async function trackFunnelEvent(funnel: string, step: string, userId?: string) {
  await supabase.from('funnel_events').insert({
    funnel_type: funnel,
    step: step,
    user_id: userId,
    session_id: getSessionId(),
    timestamp: new Date().toISOString(),
  });
}

// 퍼널 분석 조회
async function analyzeFunnel(funnelType: string, period: 'day' | 'week' | 'month'): Promise<FunnelStep[]> {
  const { data, error } = await supabase.rpc('analyze_funnel', {
    funnel_type: funnelType,
    period_type: period,
  });

  if (error) throw error;

  // 전환율 계산
  const totalCount = data[0]?.count || 1;
  return data.map((item, index) => ({
    step: item.step,
    count: item.count,
    conversionRate: (item.count / totalCount) * 100,
    dropOffRate: index > 0 ? ((data[index - 1].count - item.count) / data[index - 1].count) * 100 : 0,
  }));
}
```

---

## 📊 카테고리 분석

### 5.1 카테고리별 통계

```typescript
interface CategoryStats {
  categoryId: string;
  categoryName: string;

  // 상품 수
  totalProducts: number;
  activeProducts: number;
  soldProducts: number;

  // 거래 통계
  totalTransactions: number;
  totalRevenue: number;
  averagePrice: number;

  // 성과 지표
  conversionRate: number;  // %
  averageSellTime: number; // 일
  popularityScore: number; // 0-100
}

// 카테고리별 통계 조회
async function getCategoryStats(): Promise<CategoryStats[]> {
  const { data, error } = await supabase.rpc('get_category_stats');

  if (error) throw error;

  return data;
}

// SQL 함수
CREATE OR REPLACE FUNCTION get_category_stats()
RETURNS TABLE(
  category_id UUID,
  category_name VARCHAR,
  total_products INTEGER,
  active_products INTEGER,
  sold_products INTEGER,
  total_transactions INTEGER,
  total_revenue BIGINT,
  average_price INTEGER,
  conversion_rate DECIMAL,
  average_sell_time DECIMAL,
  popularity_score DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id AS category_id,
    c.name AS category_name,
    COUNT(p.id)::INTEGER AS total_products,
    COUNT(p.id) FILTER (WHERE p.status = 'active')::INTEGER AS active_products,
    COUNT(p.id) FILTER (WHERE p.status = 'sold')::INTEGER AS sold_products,
    COUNT(t.id)::INTEGER AS total_transactions,
    COALESCE(SUM(t.amount), 0)::BIGINT AS total_revenue,
    COALESCE(AVG(p.price), 0)::INTEGER AS average_price,
    CASE
      WHEN COUNT(p.id) > 0 THEN
        (COUNT(t.id)::DECIMAL / COUNT(p.id) * 100)
      ELSE 0
    END AS conversion_rate,
    COALESCE(AVG(EXTRACT(DAY FROM (p.sold_at - p.created_at))), 0)::DECIMAL AS average_sell_time,
    CASE
      WHEN COUNT(p.id) > 0 THEN
        ((COUNT(p.id) * 0.3 + COUNT(t.id) * 0.4 + SUM(p.views) * 0.3) / GREATEST(COUNT(p.id), 1))::DECIMAL
      ELSE 0
    END AS popularity_score
  FROM categories c
  LEFT JOIN products p ON c.id = p.category_id
  LEFT JOIN transactions t ON p.id = t.product_id
  GROUP BY c.id, c.name
  ORDER BY popularity_score DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## 🌍 지역 분석

### 6.1 거래 지역 통계

```typescript
interface RegionStats {
  region: string;

  // 활동 통계
  userCount: number;
  productCount: number;
  transactionCount: number;

  // 거래 특성
  averagePrice: number;
  popularCategories: string[];

  // 성장률
  growthRate: number; // %
}

// 지역별 통계 조회
async function getRegionStats(): Promise<RegionStats[]> {
  const { data, error } = await supabase.rpc('get_region_stats');

  if (error) throw error;

  return data;
}
```

---

## 📱 이벤트 추적

### 7.1 이벤트 타입

```typescript
enum EventType {
  // 페이지 조회
  PAGE_VIEW = 'page_view',

  // 상품 관련
  PRODUCT_VIEW = 'product_view',
  PRODUCT_CREATE = 'product_create',
  PRODUCT_UPDATE = 'product_update',
  PRODUCT_DELETE = 'product_delete',

  // 사용자 행동
  SEARCH = 'search',
  FILTER_APPLY = 'filter_apply',
  WISHLIST_ADD = 'wishlist_add',
  WISHLIST_REMOVE = 'wishlist_remove',

  // 연락 및 거래
  CONTACT_SELLER = 'contact_seller',
  TRANSACTION_INITIATE = 'transaction_initiate',
  TRANSACTION_COMPLETE = 'transaction_complete',

  // QR 코드
  QR_SCAN = 'qr_scan',
  QR_GENERATE = 'qr_generate',

  // 사용자 계정
  USER_SIGNUP = 'user_signup',
  USER_LOGIN = 'user_login',
  USER_LOGOUT = 'user_logout',
}

// 이벤트 추적 함수
async function trackEvent(
  eventType: EventType,
  eventData?: any,
  userId?: string
) {
  const event = {
    event_type: eventType,
    event_data: eventData,
    user_id: userId,
    session_id: getSessionId(),
    timestamp: new Date().toISOString(),
    user_agent: navigator.userAgent,
    referrer: document.referrer,
    page_url: window.location.href,
  };

  // 데이터베이스에 저장
  await supabase.from('events').insert(event);

  // Google Analytics (선택적)
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', eventType, eventData);
  }
}

// 사용 예시
trackEvent(EventType.PRODUCT_VIEW, {
  productId: 'abc-123',
  productTitle: '아이폰 13 Pro',
  price: 800000,
  category: '전자기기',
});

trackEvent(EventType.SEARCH, {
  query: '아이폰',
  resultCount: 42,
});

trackEvent(EventType.CONTACT_SELLER, {
  productId: 'abc-123',
  sellerId: 'seller-456',
});
```

### 7.2 세션 관리

```typescript
// 세션 ID 생성 및 관리
function getSessionId(): string {
  let sessionId = sessionStorage.getItem('session_id');

  if (!sessionId) {
    sessionId = crypto.randomUUID();
    sessionStorage.setItem('session_id', sessionId);
    sessionStorage.setItem('session_start', new Date().toISOString());
  }

  return sessionId;
}

// 세션 통계
interface SessionStats {
  sessionId: string;
  userId?: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;  // 초
  pageViews: number;
  events: number;
  bounceRate: boolean; // 단일 페이지 방문 여부
}

// 세션 분석
async function analyzeSession(sessionId: string): Promise<SessionStats> {
  const { data: events, error } = await supabase
    .from('events')
    .select('*')
    .eq('session_id', sessionId)
    .order('timestamp', { ascending: true });

  if (error) throw error;

  const startTime = new Date(events[0].timestamp);
  const endTime = new Date(events[events.length - 1].timestamp);
  const duration = (endTime.getTime() - startTime.getTime()) / 1000;

  const pageViews = events.filter(e => e.event_type === EventType.PAGE_VIEW).length;
  const bounceRate = pageViews === 1;

  return {
    sessionId,
    userId: events[0].user_id,
    startTime,
    endTime,
    duration,
    pageViews,
    events: events.length,
    bounceRate,
  };
}
```

---

## 📤 데이터 내보내기

### 8.1 CSV 내보내기

```typescript
import { saveAs } from 'file-saver';

async function exportToCSV(
  dataType: 'products' | 'users' | 'transactions',
  filters?: any
) {
  // 데이터 조회
  const data = await fetchData(dataType, filters);

  // CSV 변환
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row =>
      headers.map(header =>
        JSON.stringify(row[header] || '')
      ).join(',')
    ),
  ].join('\n');

  // BOM 추가 (한글 깨짐 방지)
  const blob = new Blob(['\uFEFF' + csvContent], {
    type: 'text/csv;charset=utf-8;',
  });

  // 파일 저장
  const filename = `${dataType}_${new Date().toISOString()}.csv`;
  saveAs(blob, filename);
}
```

### 8.2 Excel 내보내기

```typescript
import * as XLSX from 'xlsx';

async function exportToExcel(
  dataType: string,
  data: any[],
  filename: string
) {
  // 워크시트 생성
  const ws = XLSX.utils.json_to_sheet(data);

  // 열 너비 자동 조정
  const colWidths = Object.keys(data[0]).map(key => ({
    wch: Math.max(key.length, 15),
  }));
  ws['!cols'] = colWidths;

  // 워크북 생성
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, dataType);

  // 파일 저장
  XLSX.writeFile(wb, filename);
}
```

---

## 📊 리포트 생성

### 9.1 자동 리포트

```typescript
interface Report {
  id: string;
  type: 'daily' | 'weekly' | 'monthly';
  period: {
    start: Date;
    end: Date;
  };
  kpis: PlatformKPIs;
  trends: TrendData[];
  insights: string[];
  generatedAt: Date;
}

// 일일 리포트 생성
async function generateDailyReport(): Promise<Report> {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  // KPI 수집
  const kpis = await calculateKPIs('today');

  // 트렌드 데이터
  const trends = await getDailyTrend('transactions', 7);

  // 인사이트 생성
  const insights = generateInsights(kpis, trends);

  const report: Report = {
    id: crypto.randomUUID(),
    type: 'daily',
    period: {
      start: new Date(today.setHours(0, 0, 0, 0)),
      end: new Date(today.setHours(23, 59, 59, 999)),
    },
    kpis,
    trends,
    insights,
    generatedAt: new Date(),
  };

  // 데이터베이스에 저장
  await supabase.from('reports').insert(report);

  // 관리자에게 이메일 발송
  await sendReportEmail(report);

  return report;
}

// 인사이트 생성
function generateInsights(kpis: PlatformKPIs, trends: TrendData[]): string[] {
  const insights: string[] = [];

  // 성장률 분석
  if (kpis.userGrowthRate > 10) {
    insights.push(`사용자가 ${kpis.userGrowthRate.toFixed(1)}% 증가했습니다! 🎉`);
  }

  // 거래 트렌드
  const recentTrend = trends.slice(-3);
  const avgChange = recentTrend.reduce((sum, t) => sum + (t.change || 0), 0) / recentTrend.length;
  if (avgChange > 0) {
    insights.push(`최근 3일간 거래가 평균 ${avgChange.toFixed(1)}% 증가하고 있습니다.`);
  }

  // 전환율 분석
  if (kpis.conversionRate < 20) {
    insights.push(`전환율이 ${kpis.conversionRate.toFixed(1)}%로 낮습니다. UX 개선이 필요합니다.`);
  }

  // 사용자 참여
  const engagementRate = (kpis.activeUsers / kpis.totalUsers) * 100;
  if (engagementRate < 30) {
    insights.push(`활성 사용자 비율이 ${engagementRate.toFixed(1)}%입니다. 재참여 캠페인을 고려하세요.`);
  }

  return insights;
}
```

### 9.2 리포트 스케줄링

```typescript
// Vercel Cron Jobs 또는 Supabase Edge Functions 사용
// vercel.json
{
  "crons": [
    {
      "path": "/api/cron/daily-report",
      "schedule": "0 9 * * *"  // 매일 오전 9시
    },
    {
      "path": "/api/cron/weekly-report",
      "schedule": "0 9 * * 1"  // 매주 월요일 오전 9시
    },
    {
      "path": "/api/cron/monthly-report",
      "schedule": "0 9 1 * *"  // 매월 1일 오전 9시
    }
  ]
}

// API Route: /api/cron/daily-report
export async function GET(request: Request) {
  // 보안: Cron 비밀키 확인
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const report = await generateDailyReport();
    return Response.json({ success: true, report });
  } catch (error) {
    console.error('Report generation failed:', error);
    return Response.json({ success: false, error }, { status: 500 });
  }
}
```

---

## 🔔 알림 시스템

### 10.1 알림 트리거

```typescript
interface NotificationTrigger {
  condition: string;
  threshold: number;
  action: () => Promise<void>;
}

// 알림 트리거 정의
const notificationTriggers: NotificationTrigger[] = [
  {
    condition: 'newUsersToday',
    threshold: 50,
    action: async () => {
      await sendSlackNotification('🎉 오늘 신규 가입자가 50명을 돌파했습니다!');
    },
  },
  {
    condition: 'conversionRate',
    threshold: 15,
    action: async () => {
      await sendEmail({
        to: 'admin@everseconds.com',
        subject: '⚠️ 전환율 경고',
        body: '전환율이 15% 이하로 떨어졌습니다. 확인이 필요합니다.',
      });
    },
  },
  {
    condition: 'errorRate',
    threshold: 5,
    action: async () => {
      await sendPagerDutyAlert('Critical: Error rate exceeds 5%');
    },
  },
];

// 알림 체크 및 발송
async function checkAndSendNotifications() {
  const kpis = await calculateKPIs('today');

  for (const trigger of notificationTriggers) {
    const value = kpis[trigger.condition];

    if (value && value >= trigger.threshold) {
      await trigger.action();
    }
  }
}
```

### 10.2 Slack 통합

```typescript
async function sendSlackNotification(message: string, channel: string = '#analytics') {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL!;

  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      channel,
      text: message,
      username: 'Analytics Bot',
      icon_emoji: ':bar_chart:',
    }),
  });
}
```

---

## 🔐 데이터 보안 및 프라이버시

### 11.1 데이터 익명화

```typescript
// PII (Personally Identifiable Information) 마스킹
function maskEmail(email: string): string {
  const [username, domain] = email.split('@');
  const maskedUsername = username.slice(0, 2) + '***';
  return `${maskedUsername}@${domain}`;
}

function maskPhone(phone: string): string {
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1-****-$2');
}

// 익명화된 분석 데이터
interface AnonymizedUserData {
  userId: string;        // 해시된 ID
  ageGroup: string;      // "20대", "30대" 등
  region: string;        // "서울시", "경기도" 등 (구체적인 주소 제외)
  activityLevel: string; // "high", "medium", "low"
}
```

### 11.2 데이터 보관 정책

```typescript
// 데이터 보관 기간
const dataRetentionPolicy = {
  events: 90,          // 일
  logs: 30,
  reports: 365,
  transactions: Infinity, // 영구 보관
};

// 오래된 데이터 삭제
async function cleanupOldData() {
  const now = new Date();

  for (const [table, days] of Object.entries(dataRetentionPolicy)) {
    if (days === Infinity) continue;

    const cutoffDate = new Date(now);
    cutoffDate.setDate(cutoffDate.getDate() - days);

    await supabase
      .from(table)
      .delete()
      .lt('created_at', cutoffDate.toISOString());
  }
}
```

---

## 📊 시각화

### 12.1 차트 라이브러리

```typescript
import { LineChart, BarChart, PieChart, AreaChart } from 'recharts';

// 라인 차트 (트렌드)
function TrendChart({ data }: { data: TrendData[] }) {
  return (
    <LineChart width={600} height={300} data={data}>
      <XAxis dataKey="date" />
      <YAxis />
      <Tooltip />
      <Line type="monotone" dataKey="value" stroke="#2563eb" />
    </LineChart>
  );
}

// 바 차트 (카테고리별 비교)
function CategoryChart({ data }: { data: CategoryStats[] }) {
  return (
    <BarChart width={600} height={300} data={data}>
      <XAxis dataKey="categoryName" />
      <YAxis />
      <Tooltip />
      <Bar dataKey="totalProducts" fill="#2563eb" />
    </BarChart>
  );
}

// 파이 차트 (비율)
function MarketShareChart({ data }: { data: any[] }) {
  return (
    <PieChart width={400} height={300}>
      <Pie
        data={data}
        dataKey="value"
        nameKey="name"
        cx="50%"
        cy="50%"
        outerRadius={100}
        fill="#2563eb"
        label
      />
      <Tooltip />
    </PieChart>
  );
}
```

---

## 🧪 A/B 테스트

### 13.1 실험 설정

```typescript
interface Experiment {
  id: string;
  name: string;
  description: string;
  variants: {
    id: string;
    name: string;
    weight: number; // 0-1 (트래픽 비율)
  }[];
  startDate: Date;
  endDate?: Date;
  status: 'draft' | 'running' | 'completed';
}

// 실험 생성
async function createExperiment(experiment: Omit<Experiment, 'id'>): Promise<Experiment> {
  const { data, error } = await supabase
    .from('experiments')
    .insert({ ...experiment, id: crypto.randomUUID() })
    .select()
    .single();

  if (error) throw error;

  return data;
}

// 사용자를 변형에 할당
function assignVariant(experimentId: string, userId: string): string {
  // 해시 기반 일관된 할당
  const hash = crypto.createHash('md5')
    .update(`${experimentId}:${userId}`)
    .digest('hex');

  const hashValue = parseInt(hash.slice(0, 8), 16) / 0xffffffff;

  // 실험 조회 및 변형 선택
  // ... (생략)

  return variantId;
}
```

---

## 📈 성능 모니터링

### 14.1 메트릭 수집

```typescript
interface PerformanceMetrics {
  // Web Vitals
  lcp: number;  // Largest Contentful Paint
  fid: number;  // First Input Delay
  cls: number;  // Cumulative Layout Shift

  // Custom Metrics
  apiResponseTime: number;
  databaseQueryTime: number;
  imageLoadTime: number;
}

// Web Vitals 측정
import { getCLS, getFID, getLCP } from 'web-vitals';

function measureWebVitals() {
  getCLS(metric => sendMetric('cls', metric.value));
  getFID(metric => sendMetric('fid', metric.value));
  getLCP(metric => sendMetric('lcp', metric.value));
}

async function sendMetric(name: string, value: number) {
  await supabase.from('performance_metrics').insert({
    metric_name: name,
    value: value,
    page_url: window.location.href,
    timestamp: new Date().toISOString(),
  });
}
```

---

**문서 버전**: 1.0
**최종 수정일**: 2025-10-30
**작성자**: 에버세컨즈 개발팀
**관련 문서**: [프로젝트 개요](./프로젝트_개요.md), [데이터베이스 구조 설계서](./데이터베이스_구조_설계서.md)
